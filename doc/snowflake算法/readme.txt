项目中一般采用hibernate自带的主键生成策略 ，在分布式的高并发项目，可能会出现主键重复，所以采用twitter的开源项目snowflake算法进行主键生成。 
SnowFlake的结构如下(每部分用-分开):
1位标志位 41位时间戳 5位机器+5位数据标志 12位计数器 
0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 
41位时间戳是因为当前时间减去起始时间的时间戳刚好在2^41范围内 
1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0 
41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截) 
得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker 类的startTime属性）。41位的时间截，可以使用69年，年T = (1L << 41) / (1000L * 60 * 60 * 24 * 365) = 69
10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId
12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号
加起来刚好64位，为一个Long型。
SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。 
基本上snowflake算法只要在不调整机器时间或者在特殊时间（如进行闰秒调整时期将秒数减一）不会出现重复id，且生成速度快。 
代码部分:首先将snowflake中的官方demo进行适当调整，因为不需要那么多机器所以将结构调整为 1 43 3 3 14的结构。